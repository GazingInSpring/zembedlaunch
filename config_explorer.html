<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>zembed-1 Configuration Explorer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.35.0.min.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #f5f5f7; padding: 40px 20px; color: #1a1a1a;
    -webkit-font-smoothing: antialiased;
}
.page { max-width: 1100px; margin: 0 auto; }
.card {
    background: white; border-radius: 16px; border: 1px solid #e5e5e5;
    box-shadow: 0 4px 24px rgba(0,0,0,0.05); padding: 32px 40px; margin-bottom: 28px;
}
.card h2 { font-size: 20px; font-weight: 700; letter-spacing: -0.02em; margin-bottom: 6px; }
.card .desc { font-size: 14px; color: #888; margin-bottom: 24px; line-height: 1.5; }
.input-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 16px; margin-bottom: 20px;
}
.input-group label {
    display: block; font-size: 11px; font-weight: 600; color: #888;
    text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;
}
.input-group input {
    width: 100%; padding: 10px 14px; border: 1px solid #ddd; border-radius: 8px;
    font-size: 14px; font-family: inherit; background: #fafafa; transition: border-color 0.15s;
}
.input-group input:focus { outline: none; border-color: #4f46e5; background: white; }
.input-hint { font-size: 11px; color: #aaa; margin-top: 3px; }
.divider { height: 1px; background: #eee; margin: 20px 0; }
.filter-section { margin-bottom: 16px; }
.filter-section-label {
    font-size: 11px; font-weight: 600; color: #888;
    text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;
}
.filter-row { display: flex; flex-wrap: wrap; gap: 8px; }
.filter-chip {
    padding: 5px 14px; border: 1px solid #ddd; border-radius: 20px;
    font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s;
    background: white; user-select: none;
}
.filter-chip:hover { background: #f0f0f0; }
.filter-chip.active { background: #4f46e5; color: white; border-color: #4f46e5; }
.ternary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-top: 8px; }
.ternary-box h3 { font-size: 14px; font-weight: 600; color: #555; margin-bottom: 4px; text-align: center; }
.ternary-box .sub { font-size: 12px; color: #aaa; text-align: center; margin-bottom: 8px; }
.ternary-box {
    display: flex;
    flex-direction: column;
}
.ternary-box > div:last-child {
    margin-top: auto;
}
.scatter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-top: 8px; }
.scatter-box {
    position: relative; height: 360px; background: #fafafa;
    border: 1px solid #eee; border-radius: 12px; padding: 16px;
}
.filter-chip.active.dominated {
    background: #e0e0e0;
    color: #999;
    border-color: #ccc;
    text-decoration: line-through;
}
.filter-chip .dom-tag {
    font-size: 9px;
    font-weight: 600;
    color: #aaa;
    margin-left: 4px;
    text-decoration: none;
    display: inline-block;
}
.scatter-box h3 { font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #555; }
.scatter-box canvas { max-height: 300px; }
.result-table { width: 100%; border-collapse: collapse; font-size: 13px; }
.result-table thead th {
    text-align: left; padding: 10px 12px; font-size: 10px; font-weight: 700;
    text-transform: uppercase; letter-spacing: 0.5px; color: #999;
    border-bottom: 2px solid #eee; cursor: pointer; user-select: none; white-space: nowrap;
}
.result-table thead th:hover { color: #4f46e5; }
.result-table thead th.num { text-align: right; }
.result-table tbody td { padding: 11px 12px; border-bottom: 1px solid #f0f0f0; }
.result-table tbody td.num {
    text-align: right; font-variant-numeric: tabular-nums;
    font-family: 'SF Mono', 'Monaco', monospace; font-size: 12px;
}
.result-table tbody tr { transition: background 0.1s; }
.result-table tbody tr:hover { background: #f8f8ff; }
.result-table tbody tr.is-ze { background: #f5f3ff; }
.result-table tbody tr.is-ze:hover { background: #ede9fe; }
.model-dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    margin-right: 8px; vertical-align: middle;
}
.tag {
    display: inline-block; font-size: 10px; font-weight: 600;
    padding: 2px 7px; border-radius: 4px; margin-left: 4px;
}
.tag-green { background: #ecfdf5; color: #059669; }
.tag-red { background: #fef2f2; color: #dc2626; }
.tag-blue { background: #eff6ff; color: #3b82f6; }
.section-label td {
    font-size: 10px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1px; color: #bbb; padding: 14px 12px 6px; border-bottom: 1px solid #f0f0f0;
}
.footnote { font-size: 11px; color: #aaa; line-height: 1.6; margin-top: 20px; }
@media (max-width: 800px) {
    .ternary-grid, .scatter-grid { grid-template-columns: 1fr; }
    .input-grid { grid-template-columns: 1fr 1fr; }
}
</style>
</head>
<body>
<div class="page">
<div class="card">
    <h2>Your Workload</h2>
    <p class="desc">Enter your expected usage to see accurate cost comparisons across all configurations.</p>
    <div class="input-grid">
        <div class="input-group">
            <label>Corpus Size (docs)</label>
            <input type="text" id="corpusSize" value="10,000,000" oninput="recalc()">
        </div>
        <div class="input-group">
            <label>Avg Tokens / Document</label>
            <input type="text" id="avgDocTokens" value="512" oninput="recalc()">
        </div>
        <div class="input-group">
            <label>Queries / Month</label>
            <input type="text" id="queriesMonth" value="1,000,000" oninput="recalc()">
        </div>
        <div class="input-group">
            <label>Avg Tokens / Query</label>
            <input type="text" id="avgQueryTokens" value="32" oninput="recalc()">
        </div>
        <div class="input-group">
            <label>Vector DB $/GB/mo</label>
            <input type="text" id="vectorDbCost" value="0.15" oninput="recalc()">
            <div class="input-hint">Pinecone ≈ 0.33 · Qdrant ≈ 0.15 · Self-host ≈ 0.05</div>
        </div>
    </div>
</div>
<div class="card">
    <h2>Priority Tradeoff Map</h2>
    <p class="desc">Each point represents a weighting of cost, latency, and accuracy priorities. Color shows the optimal configuration. Toggle configurations to include in the comparison.</p>
    <div class="ternary-grid">
        <div class="ternary-box">
            <h3>Public Cloud</h3>
            <div class="sub">ZE Serverless + all competitors</div>
            <div class="filter-row" id="ternaryTogglesCloud" style="margin-bottom:12px;justify-content:center;"></div>
            <div id="ternaryCloud" style="width:100%;height:500px;"></div>
        </div>
        <div class="ternary-box">
            <h3>VPC / Private</h3>
            <div class="sub">AWS/Azure PrivateLink deployments</div>
            <div class="filter-row" id="ternaryTogglesVpc" style="margin-bottom:12px;justify-content:center;"></div>
            <div id="ternaryVpc" style="width:100%;height:500px;"></div>
        </div>
    </div>
</div>
<div class="card">
    <h2>Scatter Comparison</h2>
    <p class="desc">Filter configurations to compare on cost vs accuracy and latency vs accuracy.</p>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:16px;margin-bottom:20px;">
        <div class="filter-section">
            <div class="filter-section-label">Provider</div>
            <div class="filter-row" id="filterProvider"></div>
        </div>
        <div class="filter-section">
            <div class="filter-section-label">Quantization</div>
            <div class="filter-row" id="filterQuant"></div>
        </div>
        <div class="filter-section">
            <div class="filter-section-label">Matryoshka</div>
            <div class="filter-row" id="filterMatryoshka"></div>
        </div>
        <div class="filter-section">
            <div class="filter-section-label">Security</div>
            <div class="filter-row" id="filterSecurity"></div>
        </div>
    </div>
    <div class="divider"></div>
    <div class="scatter-grid">
        <div class="scatter-box">
            <h3>Monthly Cost vs Recall@10</h3>
            <canvas id="scatterCostAcc"></canvas>
        </div>
        <div class="scatter-box">
            <h3>Latency vs Recall@10</h3>
            <canvas id="scatterLatAcc"></canvas>
        </div>
    </div>
</div>
<div class="card">
    <h2>Configuration Comparison</h2>
    <p class="desc">Click column headers to sort. Respects filters above. All costs are monthly.</p>
    <div style="overflow-x:auto;">
        <table class="result-table" id="resultTable">
            <thead><tr>
                <th data-col="name">Model</th>
                <th data-col="infra">Infra</th>
                <th data-col="dims" class="num">Dims</th>
                <th data-col="quantization">Quant</th>
                <th data-col="storage" class="num">Storage</th>
                <th data-col="embedCost" class="num">Embed†</th>
                <th data-col="queryCost" class="num">Query/mo</th>
                <th data-col="storageCost" class="num">Storage/mo</th>
                <th data-col="totalCost" class="num">Total/mo</th>
                <th data-col="accuracy" class="num">Recall@10</th>
                <th data-col="latency" class="num">Latency</th>
            </tr></thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <div class="footnote">
        † One-time embedding cost amortized over 12 months. Storage = docs × dims × bits ÷ 8.
    </div>
</div>
<script>
const ALL_CONFIGS = [{"id": "zembed-1-f32-full-cloud", "name": "zembed-1", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "full", "dims": 2048, "bits_per_dim": 32, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.0, "color": "#4f46e5", "group": "zembed-1"}, {"id": "zembed-1-f32-half-cloud", "name": "zembed-1 (\u00bd dim)", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "\u00bd", "dims": 1024, "bits_per_dim": 32, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.015, "color": "#6366f1", "group": "zembed-1"}, {"id": "zembed-1-f32-quarter-cloud", "name": "zembed-1 (\u00bc dim)", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "\u00bc", "dims": 512, "bits_per_dim": 32, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.04, "color": "#818cf8", "group": "zembed-1"}, {"id": "zembed-1-f32-eighth-cloud", "name": "zembed-1 (\u215b dim)", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "\u215b", "dims": 256, "bits_per_dim": 32, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.08, "color": "#c7d2fe", "group": "zembed-1"}, {"id": "zembed-1-int8-full-cloud", "name": "zembed-1 (int8)", "provider": "ZeroEntropy", "quantization": "int8", "matryoshka": "full", "dims": 2048, "bits_per_dim": 8, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.005, "color": "#7c3aed", "group": "zembed-1"}, {"id": "zembed-1-int8-half-cloud", "name": "zembed-1 (\u00bd dim, int8)", "provider": "ZeroEntropy", "quantization": "int8", "matryoshka": "\u00bd", "dims": 1024, "bits_per_dim": 8, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.02, "color": "#8b5cf6", "group": "zembed-1"}, {"id": "zembed-1-bin-full-cloud", "name": "zembed-1 (binary)", "provider": "ZeroEntropy", "quantization": "binary", "matryoshka": "full", "dims": 2048, "bits_per_dim": 1, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.025, "color": "#a78bfa", "group": "zembed-1"}, {"id": "zembed-1-bin-half-cloud", "name": "zembed-1 (\u00bd dim, binary)", "provider": "ZeroEntropy", "quantization": "binary", "matryoshka": "\u00bd", "dims": 1024, "bits_per_dim": 1, "infra": "ZE Serverless", "price_per_m_tokens": 0.06, "latency_ms": 45, "security": "cloud", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.035, "color": "#a5b4fc", "group": "zembed-1"}, {"id": "zembed-1-f32-full-vpc", "name": "zembed-1 (VPC)", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "full", "dims": 2048, "bits_per_dim": 32, "infra": "AWS/Azure VPC", "price_per_m_tokens": 0.08, "latency_ms": 35, "security": "vpc", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.0, "color": "#4f46e5", "group": "zembed-1"}, {"id": "zembed-1-f32-half-vpc", "name": "zembed-1 (\u00bd dim, VPC)", "provider": "ZeroEntropy", "quantization": "float32", "matryoshka": "\u00bd", "dims": 1024, "bits_per_dim": 32, "infra": "AWS/Azure VPC", "price_per_m_tokens": 0.08, "latency_ms": 35, "security": "vpc", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.015, "color": "#6366f1", "group": "zembed-1"}, {"id": "zembed-1-bin-half-vpc", "name": "zembed-1 (\u00bd dim, binary, VPC)", "provider": "ZeroEntropy", "quantization": "binary", "matryoshka": "\u00bd", "dims": 1024, "bits_per_dim": 1, "infra": "AWS/Azure VPC", "price_per_m_tokens": 0.08, "latency_ms": 35, "security": "vpc", "checkpoint": "zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450", "accuracy_penalty": 0.035, "color": "#a5b4fc", "group": "zembed-1"}, {"id": "voyage-4-large", "name": "Voyage 4 Large", "provider": "Voyage", "quantization": "float32", "matryoshka": "full", "dims": 2048, "bits_per_dim": 32, "infra": "Voyage Cloud", "price_per_m_tokens": 0.12, "latency_ms": 60, "security": "cloud", "checkpoint": "aimodel-embed/modal/voyage-4.zeroentropy.dev", "accuracy_penalty": 0.0, "color": "#f59e0b", "group": "Competitors"}, {"id": "voyage-4", "name": "Voyage 4", "provider": "Voyage", "quantization": "float32", "matryoshka": "full", "dims": 1024, "bits_per_dim": 32, "infra": "Voyage Cloud", "price_per_m_tokens": 0.06, "latency_ms": 40, "security": "cloud", "checkpoint": "aimodel-embed/modal/voyage-4.zeroentropy.dev", "accuracy_penalty": 0.01, "color": "#d97706", "group": "Competitors"}, {"id": "voyage-4-lite", "name": "Voyage 4 Lite", "provider": "Voyage", "quantization": "float32", "matryoshka": "full", "dims": 512, "bits_per_dim": 32, "infra": "Voyage Cloud", "price_per_m_tokens": 0.02, "latency_ms": 25, "security": "cloud", "checkpoint": "aimodel-embed/modal/zeroentropy--voyage-4-nano-model-endpoint.modal.run", "accuracy_penalty": 0.0, "color": "#fbbf24", "group": "Competitors"}, {"id": "openai-3-large", "name": "text-embedding-3-large", "provider": "OpenAI", "quantization": "float32", "matryoshka": "full", "dims": 3072, "bits_per_dim": 32, "infra": "OpenAI Cloud", "price_per_m_tokens": 0.13, "latency_ms": 50, "security": "cloud", "checkpoint": "aimodel-embed/openai/text-embedding-3-large", "accuracy_penalty": 0.0, "color": "#10a37f", "group": "Competitors"}, {"id": "openai-3-small", "name": "text-embedding-3-small", "provider": "OpenAI", "quantization": "float32", "matryoshka": "full", "dims": 1536, "bits_per_dim": 32, "infra": "OpenAI Cloud", "price_per_m_tokens": 0.02, "latency_ms": 35, "security": "cloud", "checkpoint": "aimodel-embed/openai/text-embedding-3-small", "accuracy_penalty": 0.0, "color": "#6ee7b7", "group": "Competitors"}, {"id": "cohere-embed-4", "name": "Cohere Embed 4", "provider": "Cohere", "quantization": "float32", "matryoshka": "full", "dims": 1024, "bits_per_dim": 32, "infra": "Cohere Cloud", "price_per_m_tokens": 0.12, "latency_ms": 55, "security": "cloud", "accuracy_override": 0.72, "color": "#d946ef", "group": "Competitors"}];
const RECALL_CURVES = {"zembed-4b-v0.3.0-mix-v3.0/epoch-001-step-8450": [0.07432, 0.11991, 0.1569, 0.19005, 0.21845, 0.24193, 0.26247, 0.28404, 0.30216, 0.31819, 0.33332, 0.34752, 0.36052, 0.37331, 0.38536, 0.39702, 0.40796, 0.41847, 0.42833, 0.4374, 0.4479, 0.45637, 0.46471, 0.47143, 0.47803, 0.48402, 0.49008, 0.49667, 0.50337, 0.50871, 0.51507, 0.52131, 0.52687, 0.53186, 0.53832, 0.54176, 0.54536, 0.55015, 0.55422, 0.55769, 0.56234, 0.56601, 0.56899, 0.57305, 0.57638, 0.57968, 0.58341, 0.58704, 0.59036, 0.59458, 0.59732, 0.60027, 0.60448, 0.60725, 0.61031, 0.61334, 0.61672, 0.62019, 0.62271, 0.62524, 0.62819, 0.63077, 0.63301, 0.63549, 0.63795, 0.64024, 0.64206, 0.6436, 0.64531, 0.64818, 0.65018, 0.65234, 0.65427, 0.65595, 0.65747, 0.65979, 0.66166, 0.66461, 0.66738, 0.66866, 0.67068, 0.67294, 0.67469, 0.6771, 0.67861, 0.68072, 0.68259, 0.68388, 0.68593, 0.68765, 0.68891, 0.69072, 0.69256, 0.69438, 0.69589, 0.69717, 0.69945, 0.70065, 0.70205, 0.70387], "aimodel-embed/modal/voyage-4.zeroentropy.dev": [0.06552, 0.11047, 0.14713, 0.18214, 0.20847, 0.23352, 0.25545, 0.2778, 0.29755, 0.31541, 0.32955, 0.34344, 0.35488, 0.36702, 0.37848, 0.39, 0.40018, 0.40934, 0.41965, 0.42886, 0.43897, 0.44618, 0.45463, 0.46125, 0.46798, 0.47533, 0.48293, 0.48993, 0.49608, 0.50216, 0.50766, 0.51377, 0.52007, 0.52517, 0.53137, 0.53619, 0.54022, 0.54494, 0.54906, 0.5528, 0.55736, 0.5612, 0.56616, 0.5701, 0.57319, 0.57766, 0.58194, 0.58574, 0.59177, 0.59533, 0.59867, 0.60195, 0.60465, 0.60751, 0.61154, 0.61501, 0.61792, 0.62049, 0.62411, 0.6268, 0.6292, 0.63243, 0.63432, 0.6368, 0.63982, 0.64254, 0.64516, 0.64723, 0.64925, 0.65141, 0.65371, 0.656, 0.65809, 0.65968, 0.66295, 0.66578, 0.66791, 0.66902, 0.67123, 0.67341, 0.67512, 0.67726, 0.68011, 0.68163, 0.68394, 0.68651, 0.68814, 0.69062, 0.69271, 0.69406, 0.69685, 0.69851, 0.69988, 0.70073, 0.7023, 0.70358, 0.70509, 0.70688, 0.7086, 0.70976], "aimodel-embed/modal/zeroentropy--voyage-4-nano-model-endpoint.modal.run": [0.05638, 0.09675, 0.13112, 0.16021, 0.18599, 0.20369, 0.22397, 0.24121, 0.26075, 0.27791, 0.29193, 0.30417, 0.31532, 0.32813, 0.33751, 0.34837, 0.35963, 0.3692, 0.38091, 0.38854, 0.39687, 0.40569, 0.41239, 0.41897, 0.42692, 0.43429, 0.44101, 0.44728, 0.45281, 0.45875, 0.46393, 0.46922, 0.47464, 0.47979, 0.48357, 0.48772, 0.49389, 0.498, 0.50268, 0.50669, 0.51034, 0.51408, 0.51922, 0.52304, 0.52699, 0.53137, 0.53465, 0.53838, 0.54269, 0.54611, 0.5487, 0.55218, 0.55426, 0.55698, 0.55997, 0.56265, 0.5655, 0.56886, 0.57079, 0.57336, 0.5768, 0.57969, 0.58215, 0.58493, 0.58872, 0.59067, 0.59376, 0.59665, 0.59907, 0.60187, 0.60401, 0.60618, 0.60878, 0.61073, 0.61288, 0.615, 0.61718, 0.62007, 0.62258, 0.62486, 0.62695, 0.62867, 0.63128, 0.63338, 0.63581, 0.63738, 0.63931, 0.64115, 0.64202, 0.64346, 0.64533, 0.64695, 0.64859, 0.65007, 0.65156, 0.65318, 0.65467, 0.6567, 0.65802, 0.65975], "aimodel-embed/openai/text-embedding-3-large": [0.05532, 0.09518, 0.129, 0.15517, 0.1812, 0.20393, 0.22331, 0.24021, 0.25679, 0.27221, 0.2849, 0.29719, 0.31016, 0.32124, 0.33188, 0.34084, 0.35038, 0.36152, 0.37167, 0.38108, 0.38965, 0.39687, 0.40391, 0.41159, 0.41788, 0.42556, 0.432, 0.43706, 0.44259, 0.44823, 0.45396, 0.46013, 0.46462, 0.47109, 0.47491, 0.48086, 0.48476, 0.48911, 0.49337, 0.49779, 0.50228, 0.50722, 0.51235, 0.5163, 0.5192, 0.52309, 0.52665, 0.53082, 0.53506, 0.5378, 0.54171, 0.54441, 0.54807, 0.55063, 0.55318, 0.55619, 0.5592, 0.56154, 0.56499, 0.5676, 0.57099, 0.57377, 0.57674, 0.57922, 0.58205, 0.58475, 0.58774, 0.5903, 0.59217, 0.59511, 0.59705, 0.5992, 0.60046, 0.60352, 0.60581, 0.6074, 0.60917, 0.61086, 0.61327, 0.61494, 0.61659, 0.61822, 0.62041, 0.62221, 0.62411, 0.62659, 0.62851, 0.63038, 0.63262, 0.63453, 0.63577, 0.63698, 0.6384, 0.64056, 0.64211, 0.64338, 0.64418, 0.64555, 0.64762, 0.64892], "aimodel-embed/openai/text-embedding-3-small": [0.05151, 0.08477, 0.11496, 0.13818, 0.15794, 0.17541, 0.19028, 0.2078, 0.22551, 0.23862, 0.25051, 0.26262, 0.27486, 0.28456, 0.29497, 0.30403, 0.31223, 0.32165, 0.33063, 0.33895, 0.34642, 0.35292, 0.36058, 0.36648, 0.37338, 0.3785, 0.38443, 0.38978, 0.39519, 0.40102, 0.40625, 0.4118, 0.41791, 0.42192, 0.4269, 0.43143, 0.43509, 0.44027, 0.44571, 0.44948, 0.4536, 0.45679, 0.46053, 0.46442, 0.46803, 0.47084, 0.47447, 0.47794, 0.48129, 0.48477, 0.48774, 0.49114, 0.49541, 0.49827, 0.50135, 0.50404, 0.50718, 0.50942, 0.51144, 0.51341, 0.51588, 0.51775, 0.51942, 0.52245, 0.52522, 0.52687, 0.52903, 0.53198, 0.53416, 0.5364, 0.53918, 0.54167, 0.54366, 0.54623, 0.54847, 0.5503, 0.55218, 0.55402, 0.5554, 0.55704, 0.55932, 0.56151, 0.56352, 0.56528, 0.56747, 0.56988, 0.57274, 0.57414, 0.57644, 0.57815, 0.57944, 0.58158, 0.5836, 0.58476, 0.58689, 0.58874, 0.59046, 0.59338, 0.59558, 0.59779]};
const RECALL_K = 10;

const filters = { provider: new Set(), quant: new Set(), matryoshka: new Set(), security: new Set() };
let sortCol = 'totalCost';
let sortAsc = true;
let scatterChart1 = null;
let scatterChart2 = null;

function parseNum(id) {
    return parseFloat(document.getElementById(id).value.replace(/,/g, '')) || 0;
}
function fmtDollars(n) {
    if (n >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
    if (n >= 1000) return '$' + n.toLocaleString('en-US', { maximumFractionDigits: 0 });
    if (n >= 1) return '$' + n.toFixed(2);
    return '$' + n.toFixed(3);
}
function fmtDollarsMo(n) {
    if (n >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M/mo';
    if (n >= 1000) return '$' + n.toLocaleString('en-US', { maximumFractionDigits: 0 }) + '/mo';
    if (n >= 1) return '$' + n.toFixed(0) + '/mo';
    return '$' + n.toFixed(2) + '/mo';
}
function fmtStorage(bytes) {
    const gb = bytes / (1024 ** 3);
    if (gb >= 1000) return (gb / 1000).toFixed(1) + ' TB';
    if (gb >= 1) return gb.toFixed(1) + ' GB';
    return (gb * 1024).toFixed(0) + ' MB';
}
function getAccuracy(c) {
    if (c.accuracy_override !== undefined) return c.accuracy_override;
    if (c.checkpoint && RECALL_CURVES[c.checkpoint])
        return Math.max(0, RECALL_CURVES[c.checkpoint][RECALL_K - 1] - (c.accuracy_penalty || 0));
    return 0;
}
function computeRow(c) {
    const corpusSize = parseNum('corpusSize');
    const avgDocTokens = parseNum('avgDocTokens');
    const queriesMonth = parseNum('queriesMonth');
    const avgQueryTokens = parseNum('avgQueryTokens');
    const vectorDbCost = parseNum('vectorDbCost');
    const totalDocTokens = corpusSize * avgDocTokens;
    const monthlyQueryTokens = queriesMonth * avgQueryTokens;
    const embedCost = (totalDocTokens / 1e6) * c.price_per_m_tokens;
    const queryCost = (monthlyQueryTokens / 1e6) * c.price_per_m_tokens;
    const storageBytes = corpusSize * c.dims * (c.bits_per_dim / 8);
    const storageCost = (storageBytes / (1024 ** 3)) * vectorDbCost;
    const totalCost = (embedCost / 12) + queryCost + storageCost;
    return { ...c, embedCost, queryCost, storageBytes, storageCost, totalCost, accuracy: getAccuracy(c) };
}
function getAllRows() { return ALL_CONFIGS.map(computeRow); }
function getFilteredRows() {
    return getAllRows().filter(r =>
        filters.provider.has(r.provider) &&
        filters.quant.has(r.quantization) &&
        filters.matryoshka.has(r.matryoshka) &&
        filters.security.has(r.security)
    );
}

// ── Filters ──
function initFilters() {
    const unique = (key) => [...new Set(ALL_CONFIGS.map(c => c[key]))];
    initChips('filterProvider', unique('provider'), 'provider');
    initChips('filterQuant', unique('quantization'), 'quant');
    initChips('filterMatryoshka', unique('matryoshka'), 'matryoshka');
    initChips('filterSecurity', unique('security'), 'security');
}
function initChips(containerId, values, filterKey) {
    const el = document.getElementById(containerId);
    values.forEach(v => {
        filters[filterKey].add(v);
        const chip = document.createElement('span');
        chip.className = 'filter-chip active';
        chip.textContent = v;
        chip.onclick = () => {
            if (filters[filterKey].has(v)) { filters[filterKey].delete(v); chip.classList.remove('active'); }
            else { filters[filterKey].add(v); chip.classList.add('active'); }
            recalc();
        };
        el.appendChild(chip);
    });
}

// ── Ternary ──
// ── Ternary ──
const TERNARY_RES = 80;
const ternaryState = {};
const ternaryToggles = { cloud: new Set(), vpc: new Set() };

function initTernaryToggles() {
    const allRows = getAllRows();
    initTernaryToggleSet('ternaryTogglesCloud', 'cloud', allRows.filter(r => r.security === 'cloud'));
    initTernaryToggleSet('ternaryTogglesVpc', 'vpc', allRows.filter(r => r.security === 'vpc'));
}

function initTernaryToggleSet(containerId, secKey, rows) {
    const el = document.getElementById(containerId);
    const seen = new Set();
    for (const r of rows) {
        if (seen.has(r.id)) continue;
        seen.add(r.id);
        ternaryToggles[secKey].add(r.id);
        const chip = document.createElement('span');
        chip.className = 'filter-chip active';
        chip.style.borderLeft = '4px solid ' + r.color;
        chip.textContent = r.name;
        chip.dataset.configId = r.id;
        chip.onclick = () => {
            if (ternaryToggles[secKey].has(r.id)) {
                ternaryToggles[secKey].delete(r.id);
                chip.classList.remove('active');
            } else {
                ternaryToggles[secKey].add(r.id);
                chip.classList.add('active');
            }
            recalcTernary();
        };
        el.appendChild(chip);
    }
}

function recalcTernary() {
    const all = getAllRows();
    const cloudRows = all.filter(r => r.security === 'cloud' && ternaryToggles.cloud.has(r.id));
    const vpcRows = all.filter(r => r.security === 'vpc' && ternaryToggles.vpc.has(r.id));
    renderTernary('ternaryCloud', cloudRows);
    renderTernary('ternaryVpc', vpcRows);
}

function renderTernary(divId, rows) {
    const secKey = divId === 'ternaryCloud' ? 'cloud' : 'vpc';
    const toggleContainer = document.getElementById(
        divId === 'ternaryCloud' ? 'ternaryTogglesCloud' : 'ternaryTogglesVpc'
    );

    if (rows.length === 0) {
        Plotly.purge(divId);
        document.getElementById(divId).innerHTML =
            '<p style="text-align:center;color:#aaa;padding:80px 20px;">No configurations selected.</p>';
        for (const chip of toggleContainer.children) {
            chip.classList.remove('dominated');
            const dt = chip.querySelector('.dom-tag');
            if (dt) dt.remove();
        }
        return;
    }


    const minCost = Math.min(...rows.map(r => r.totalCost));
    const maxCost = Math.max(...rows.map(r => r.totalCost));
    const minLat = Math.min(...rows.map(r => r.latency_ms));
    const maxLat = Math.max(...rows.map(r => r.latency_ms));
    const minAcc = Math.min(...rows.map(r => r.accuracy));
    const maxAcc = Math.max(...rows.map(r => r.accuracy));

    const normVal = (v, lo, hi, inv) => {
        const n = hi > lo ? (v - lo) / (hi - lo) : 0.5;
        return inv ? 1 - n : n;
    };
    const normed = rows.map(r => ({
        nCost: normVal(r.totalCost, minCost, maxCost, true),
        nLat: normVal(r.latency_ms, minLat, maxLat, true),
        nAcc: normVal(r.accuracy, minAcc, maxAcc, false),
    }));

    function bestIdx(wC, wL, wA) {
        let best = 0, bestS = -Infinity;
        for (let i = 0; i < normed.length; i++) {
            const s = wC * normed[i].nCost + wL * normed[i].nLat + wA * normed[i].nAcc;
            if (s > bestS) { bestS = s; best = i; }
        }
        return best;
    }

    // Find which configs actually win somewhere
    const winners = new Set();
    const ta = [], tb = [], tc = [], colors = [], hover = [];
    for (let i = 0; i <= TERNARY_RES; i++) {
        for (let j = 0; j <= TERNARY_RES - i; j++) {
            const k = TERNARY_RES - i - j;
            const wC = i / TERNARY_RES, wL = j / TERNARY_RES, wA = k / TERNARY_RES;
            const idx = bestIdx(wC, wL, wA);
            winners.add(idx);
            ta.push(wC); tb.push(wL); tc.push(wA);
            colors.push(rows[idx].color);
            hover.push(
                '<b>' + rows[idx].name + '</b>' +
                '<br>' +
                '<br>Cost: ' + fmtDollarsMo(rows[idx].totalCost) +
                '<br>Latency: ' + rows[idx].latency_ms + ' ms' +
                '<br>Recall@10: ' + (rows[idx].accuracy * 100).toFixed(1) + '%' +
                '<br>' +
                '<br><span style="color:#999">Priority weights:</span>' +
                '<br><span style="color:#999">Cost ' + (wC * 100).toFixed(0) + '% · Latency ' + (wL * 100).toFixed(0) + '% · Accuracy ' + (wA * 100).toFixed(0) + '%</span>'
            );
        }
    }

    ternaryState[divId] = { len: ta.length };

    const dotsTrace = {
        type: 'scatterternary', mode: 'markers',
        a: ta, b: tb, c: tc,
        marker: { size: 6, color: colors, line: { width: 0 }, opacity: 0.85 },
        text: hover, hoverinfo: 'text',
        hoverlabel: { bgcolor: 'white', bordercolor: '#ddd', font: { size: 12, family: 'Inter, sans-serif', color: '#1a1a1a' }, align: 'left' },
        showlegend: false,
    };

    // Only plot centroid dots for configs that actually win somewhere
    const cfgA = [], cfgB = [], cfgC = [], cfgColors = [], cfgHover = [];
    for (const i of winners) {
        const sum = normed[i].nCost + normed[i].nLat + normed[i].nAcc || 1;
        cfgA.push(normed[i].nCost / sum);
        cfgB.push(normed[i].nLat / sum);
        cfgC.push(normed[i].nAcc / sum);
        cfgColors.push(rows[i].color);
        cfgHover.push(
            '<b>' + rows[i].name + '</b>' +
            '<br>' +
            '<br>Cost: ' + fmtDollarsMo(rows[i].totalCost) +
            '<br>Latency: ' + rows[i].latency_ms + ' ms' +
            '<br>Recall@10: ' + (rows[i].accuracy * 100).toFixed(1) + '%'
        );
    }
    const cfgDotsTrace = {
        type: 'scatterternary', mode: 'markers',
        a: cfgA, b: cfgB, c: cfgC,
        marker: { size: 12, color: cfgColors, line: { color: 'white', width: 3 }, opacity: 1 },
        text: cfgHover, hoverinfo: 'text',
        hoverlabel: { bgcolor: 'white', bordercolor: '#ddd', font: { size: 12, family: 'Inter, sans-serif', color: '#1a1a1a' }, align: 'left' },
        showlegend: false,
    };

    const medianTraces = [
        { a: [1, 0], b: [0, 0.5], c: [0, 0.5] },
        { a: [0, 0.5], b: [1, 0], c: [0, 0.5] },
        { a: [0, 0.5], b: [0, 0.5], c: [1, 0] },
    ].map(m => ({
        type: 'scatterternary', mode: 'lines',
        a: m.a, b: m.b, c: m.c,
        line: { color: 'rgba(0,0,0,0.45)', width: 2.5, dash: 'dot' },
        hoverinfo: 'skip', showlegend: false,
    }));

    const cornerBest = {
        type: 'scatterternary', mode: 'text',
        a: [1, 0.05, 0.05],
        b: [0, 0.975, 0],
        c: [0, 0, 0.975],
        text: [
            'Best: ' + fmtDollarsMo(minCost) + '<br><br>',
            'Best: ' + minLat + 'ms    ',
            '     Best: ' + (maxAcc * 100).toFixed(1) + '%',
        ],
        textfont: { size: 11, color: '#059669', family: 'Inter, sans-serif' },
        textposition: ['top center', 'bottom left', 'bottom right'],
        hoverinfo: 'skip', showlegend: false, cliponaxis: false,
    };

    const midWorst = {
        type: 'scatterternary', mode: 'text',
        a: [0, 0.5, 0.5],
        b: [0.5, 0, 0.5],
        c: [0.5, 0.5, 0],
        text: [
            '<br>Worst: ' + fmtDollarsMo(maxCost),
            '    Worst: ' + maxLat + 'ms',
            'Worst: ' + (minAcc * 100).toFixed(1) + '%    ',
        ],
        textfont: { size: 10, color: '#dc2626', family: 'Inter, sans-serif' },
        textposition: ['bottom center', 'middle right', 'middle left'],
        hoverinfo: 'skip', showlegend: false, cliponaxis: false,
    };

    // Legend only for winners
    const legendTraces = [...winners].map(i => ({
        type: 'scatterternary', mode: 'markers',
        a: [null], b: [null], c: [null],
        marker: { size: 10, color: rows[i].color },
        name: rows[i].name, showlegend: true, hoverinfo: 'skip',
    }));

    Plotly.react(divId,
        [dotsTrace, ...medianTraces, cornerBest, midWorst, ...legendTraces],
        {
            ternary: {
                sum: 1,
                aaxis: { title: { text: '<b>Cost Priority</b>', font: { size: 12, color: '#444' } }, min: 0, linewidth: 2, gridcolor: 'rgba(0,0,0,0.06)', showticklabels: false },
                baxis: { title: { text: '<b>Latency Priority</b>', font: { size: 12, color: '#444' } }, min: 0, linewidth: 2, gridcolor: 'rgba(0,0,0,0.06)', showticklabels: false },
                caxis: { title: { text: '<b>Accuracy Priority</b>', font: { size: 12, color: '#444' } }, min: 0, linewidth: 2, gridcolor: 'rgba(0,0,0,0.06)', showticklabels: false },
                bgcolor: '#fafafa',
            },
            font: { family: 'Inter, -apple-system, sans-serif' },
            paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
            margin: { t: 80, b: 80, l: 80, r: 80 },
            legend: {
                orientation: 'h',
                x: 0.5,
                y: -0.05,
                xanchor: 'center',
                yanchor: 'top',
                font: { size: 11 },
                itemsizing: 'constant',
                valign: 'middle',
                itemwidth: 30,
            },
            showlegend: true,
        },
        { displayModeBar: false, responsive: true }
    );
    // Update toggle chips: mark dominated configs
    const winnerIds = new Set([...winners].map(i => rows[i].id));
    for (const chip of toggleContainer.children) {
        const cid = chip.dataset.configId;
        if (!cid) continue;
        const isActive = ternaryToggles[secKey].has(cid);
        const isWinner = winnerIds.has(cid);
        chip.classList.toggle('dominated', isActive && !isWinner);
        // Add/remove "(dominated)" tag
        let domTag = chip.querySelector('.dom-tag');
        if (isActive && !isWinner) {
            if (!domTag) {
                domTag = document.createElement('span');
                domTag.className = 'dom-tag';
                domTag.textContent = 'dominated';
                chip.appendChild(domTag);
            }
        } else if (domTag) {
            domTag.remove();
        }
    }

    const el = document.getElementById(divId);
    el.on('plotly_hover', function(data) {
        if (data.points[0].curveNumber !== 0) return;
        const idx = data.points[0].pointNumber;
        const len = ternaryState[divId].len;
        const sizes = new Array(len).fill(6);
        sizes[idx] = 14;
        const opacities = new Array(len).fill(0.85);
        opacities[idx] = 1;
        Plotly.restyle(divId, { 'marker.size': [sizes], 'marker.opacity': [opacities] }, [0]);
    });
    el.on('plotly_unhover', function() {
        const len = ternaryState[divId].len;
        Plotly.restyle(divId, {
            'marker.size': [new Array(len).fill(6)],
            'marker.opacity': [new Array(len).fill(0.85)],
        }, [0]);
    });
}
// ── Scatter ──
function renderScatter() {
    const rows = getFilteredRows();
    const pts1 = rows.map(r => ({ x: r.totalCost, y: r.accuracy, label: r.name, color: r.color }));
    const pts2 = rows.map(r => ({ x: r.latency_ms, y: r.accuracy, label: r.name, color: r.color }));

    const mkDs = (pts) => [{ data: pts.map(p => ({ x: p.x, y: p.y })), backgroundColor: pts.map(p => p.color), borderColor: pts.map(p => p.color), pointRadius: 8, pointHoverRadius: 11 }];
    const mkTt = (pts) => ({
        itemSort: (a, b) => b.parsed.y - a.parsed.y,
        callbacks: {
            label: (item) => {
                const p = pts[item.dataIndex];
                return p.label + ': (' + (p.x > 100 ? fmtDollars(p.x) : p.x) + ', ' + (p.y * 100).toFixed(1) + '%)';
            }
        }
    });
    const mkOpts = (pts, xLabel) => ({
        responsive: true, maintainAspectRatio: false,
        animation: { duration: 400, easing: 'easeInOutCubic' },
        plugins: { legend: { display: false }, tooltip: mkTt(pts) },
        scales: {
            x: { title: { display: true, text: xLabel, font: { size: 12 } } },
            y: { title: { display: true, text: 'Recall@10', font: { size: 12 } }, min: 0, max: 1 },
        },
    });

    if (scatterChart1) {
        scatterChart1.data.datasets = mkDs(pts1);
        scatterChart1.options = mkOpts(pts1, 'Monthly Cost ($)');
        scatterChart1.update();
    } else {
        scatterChart1 = new Chart(document.getElementById('scatterCostAcc'), {
            type: 'scatter', data: { datasets: mkDs(pts1) }, options: mkOpts(pts1, 'Monthly Cost ($)'),
        });
    }
    if (scatterChart2) {
        scatterChart2.data.datasets = mkDs(pts2);
        scatterChart2.options = mkOpts(pts2, 'Latency (ms)');
        scatterChart2.update();
    } else {
        scatterChart2 = new Chart(document.getElementById('scatterLatAcc'), {
            type: 'scatter', data: { datasets: mkDs(pts2) }, options: mkOpts(pts2, 'Latency (ms)'),
        });
    }
}

// ── Table ──
function renderTable() {
    const rows = getFilteredRows();
    const sortFn = (a, b) => {
        let va = a[sortCol], vb = b[sortCol];
        if (typeof va === 'string') { va = va.toLowerCase(); vb = vb.toLowerCase(); }
        return sortAsc ? (va < vb ? -1 : va > vb ? 1 : 0) : (va > vb ? -1 : va < vb ? 1 : 0);
    };
    const zeRows = rows.filter(r => r.group === 'zembed-1').sort(sortFn);
    const compRows = rows.filter(r => r.group !== 'zembed-1').sort(sortFn);
    const grouped = [...zeRows, ...compRows];
    const cheapest = rows.length > 0 ? rows.reduce((a, b) => a.totalCost < b.totalCost ? a : b) : null;

    let html = '', lastGroup = '';
    for (const r of grouped) {
        if (r.group !== lastGroup) {
            html += '<tr class="section-label"><td colspan="11">' + r.group + '</td></tr>';
            lastGroup = r.group;
        }
        const isZe = r.group === 'zembed-1';
        const sav = cheapest ? ((r.totalCost - cheapest.totalCost) / cheapest.totalCost * 100) : 0;
        const savTag = r === cheapest ? '<span class="tag tag-green">cheapest</span>'
            : sav <= 0 ? '<span class="tag tag-green">' + sav.toFixed(0) + '%</span>'
            : '<span class="tag tag-red">+' + sav.toFixed(0) + '%</span>';
        const secTag = r.security === 'vpc' ? ' <span class="tag tag-blue">VPC</span>' : '';
        html += '<tr class="' + (isZe ? 'is-ze' : '') + '">'
            + '<td><span class="model-dot" style="background:' + r.color + '"></span>' + r.name + '</td>'
            + '<td>' + r.infra + secTag + '</td>'
            + '<td class="num">' + r.dims + '</td>'
            + '<td>' + r.quantization + '</td>'
            + '<td class="num">' + fmtStorage(r.storageBytes) + '</td>'
            + '<td class="num">' + fmtDollars(r.embedCost) + '</td>'
            + '<td class="num">' + fmtDollars(r.queryCost) + '</td>'
            + '<td class="num">' + fmtDollars(r.storageCost) + '</td>'
            + '<td class="num"><strong>' + fmtDollars(r.totalCost) + '</strong> ' + savTag + '</td>'
            + '<td class="num">' + (r.accuracy * 100).toFixed(1) + '%</td>'
            + '<td class="num">' + r.latency_ms + ' ms</td>'
            + '</tr>';
    }
    document.getElementById('tableBody').innerHTML = html;
}

// ── Main ──
function recalc() {
    recalcTernary();
    renderScatter();
    renderTable();
}

document.querySelectorAll('#resultTable thead th').forEach(th => {
    th.addEventListener('click', () => {
        const col = th.dataset.col;
        if (sortCol === col) sortAsc = !sortAsc;
        else { sortCol = col; sortAsc = true; }
        renderTable();
    });
});

initFilters();
initTernaryToggles();
recalc();
</script>
</div>
</body>
</html>